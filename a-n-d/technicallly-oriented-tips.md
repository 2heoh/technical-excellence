# Технические рекомендации / Technically Oriented Tips

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/less/technical-excellence/architecture-design.html#TechnicallyOrientedTips) | *В работе* |

За то время, что мы работали с крупными продуктами, обычно это были встраиваемые системы (embedded systems), мы составили
список общих рекомендаций, которые могли бы уменьшить часть боли и страданий, которые на наших глазах испытывают наши
клиенты. В этом разделе перечислены некоторые из этих советов. Но на самом деле эта тема заслуживает отдельной книги ...

## Представьте ваш исходный код в виде HTML-страниц и гиперссылок между ними
В небольшом проекте можно быстро перемещаться по всему исходному коду, просто открытому в вашей среде разработки. Когда, к
примеру, имеется 36 839 файлов и 15 [MLOC](../DICTIONARY.md#MLOC), навигация уже не простая. Используйте бесплатный
инструменты, такие как Doxygen ([www.doxygen.org](http://www.doxygen.org)), чтобы преобразовать ваш исходный код в набор
HTML-страниц, в которых все элементы исходного кода (классы, методы, ...) являются гиперссылками. Doxygen (и аналогичные
инструменты) также будут генерировать диаграммы, отражающие более крупные структуры и группы в вашей кодовой базе.
Регенерируйте страницы ежедневно. Это очень полезно для понимания и развития огромной кодовой базы.

## Используйте заглушки и внедрение зависимостей (dependency injections)
Создавайте заглушки - или «поддельные» альтернативы кода для многих вещей: классов, интерфейсов с другими компонентами,
аппаратного обеспечения и так далее. Заглушки обычно создаются с помощью реализации альтернативного интерфейса или путем
создания подкласса «реального» класса в объектно-ориентированных проектах, или с помощью указателей функций или
альтернативных файлов реализации по изменяющемуся пути ссылки в проектах на основе C
[Feathers04](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), например:
```java
interface PrinterMotor {
    void start();
    …
}

class CanonPrinterMotor implements PrinterMotor {
    …
}

class PrinterMotorStub implements PrinterMotor {
    …
}
```

Если нет интерфейса (и даже если он есть), заглушки могут быть созданы с помощью подклассов и переопределения соответствующих
методов:
```java
class CanonPrinterMotor {
    …
}

class PrinterMotorStub extends CanonPrinterMotor {
    …
}
```

Кроме того, обеспечьте «черный ход» во многих классах, который позволяет легко внедрить альтернативную
заглушку, как зависимость, а не в реальный объект; например, с инжекции в конструктор
[Fowler04](http://martinfowler.com/articles/injection.html).
```java
class LaserPrinter {

private PrinterMotor motor = new CanonPrinterMotor(); // default …

    public Printer (PrinterMotor alternativeMotor) {
        motor = alternativeMotor;
    }
}
```

Сочетание множества заглушек с множеством «черных ходов» для внедрения зависимостей открывает огромные преимущества:
усиление параллельной разработки, ранняя интеграция с заглушками, когда реальные компоненты недоступны, тестирование
с заглушками, заглушки, которые предоставляют быстрые и хорошо известные демонстрационные данные. В контексте разработки
крупных продуктов массовое использование заглушек - это ключевой метод для параллельной работы и ускорения работы, что
сокращает затраты на ожидание.

## Не используйте заглушки, чтобы отсрочить интеграцию
Чудесно! Теперь у каждого есть заглушки и у вас есть возможность отсрочить интеграцию всего кода на месяцы или годы. Даже не
думайте об этом.

## Разработка через тестирование / Test-driven development для лучшей архитектуры
[TDD](../tdd) может улучшить архитектуру системы. Как?

Когда мы занимаетесь коучингом, частым запросом наших клиентов является просьбы помочь с "негибкой архитектурой". Это чаще
всего сводится к проблемам в сильной связанности компонентов - распространенная проблема в унаследованном (legacy) коде,
написанном без использования TDD, потому что первоначальный автор не пытался тестировать компоненты независимо.

С другой стороны, когда разработчик создает новый компонент (например, класс) с TDD или проводит рефакторинг устаревшего,
то нужно разорвать зависимости и нарушить связи этого компонента, чтобы он мог быть протестирован изолированно.
Это требует проектирования (или рефакторинга) для внедрения зависимостей и более широкого использования механизмов для
обеспечения гибкости: интерфейсов, полиморфизма, шаблонов проектирования, структур внедрения зависимостей, указателей
функций и многого другого.

В таком случае TDD поощряет слабое связывание, простоту, гибкость конфигурацию - качества хорошей архитектуры.
