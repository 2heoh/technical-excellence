# Технические рекомендации / Technically Oriented Tips

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/less/technical-excellence/architecture-design.html#TechnicallyOrientedTips) | *В работе* |

За то время, что мы работали с крупными продуктами, обычно это были встраиваемые системы (embedded systems), мы составили
список общих рекомендаций, которые могли бы уменьшить часть боли и страданий, которые на наших глазах испытывают наши
клиенты. В этом разделе перечислены некоторые из этих советов. Но на самом деле эта тема заслуживает отдельной книги ...

## Представьте ваш исходный код в виде HTML-страниц и гиперссылок между ними
В небольшом проекте можно быстро перемещаться по всему исходному коду, просто открытому в вашей среде разработки. Когда, к
примеру, имеется 36 839 файлов и 15 [MLOC](../DICTIONARY.md#MLOC), навигация уже не простая. Используйте бесплатный
инструменты, такие как Doxygen ([www.doxygen.org](http://www.doxygen.org)), чтобы преобразовать ваш исходный код в набор
HTML-страниц, в которых все элементы исходного кода (классы, методы, ...) являются гиперссылками. Doxygen (и аналогичные
инструменты) также будут генерировать диаграммы, отражающие более крупные структуры и группы в вашей кодовой базе.
Регенерируйте страницы ежедневно. Это очень полезно для понимания и развития огромной кодовой базы.

## Используйте заглушки и внедрение зависимостей (dependency injections)
Создавайте заглушки - или «поддельные» альтернативы кода для многих вещей: классов, интерфейсов с другими компонентами,
аппаратного обеспечения и так далее. Заглушки обычно создаются с помощью реализации альтернативного интерфейса или путем
создания подкласса «реального» класса в объектно-ориентированных проектах, или с помощью указателей функций или
альтернативных файлов реализации по изменяющемуся пути ссылки в проектах на основе C
[Feathers04](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), например:
```java
interface PrinterMotor {
    void start();
    …
}

class CanonPrinterMotor implements PrinterMotor {
    …
}

class PrinterMotorStub implements PrinterMotor {
    …
}
```

Если нет интерфейса (и даже если он есть), заглушки могут быть созданы с помощью подклассов и переопределения соответствующих
методов:
```java
class CanonPrinterMotor {
    …
}

class PrinterMotorStub extends CanonPrinterMotor {
    …
}
```

Кроме того, обеспечьте «черный ход» во многих классах, который позволяет легко внедрить альтернативную
заглушку, как зависимость, а не в реальный объект; например, с инжекции в конструктор
[Fowler04](http://martinfowler.com/articles/injection.html).
```java
class LaserPrinter {

private PrinterMotor motor = new CanonPrinterMotor(); // default …

    public Printer (PrinterMotor alternativeMotor) {
        motor = alternativeMotor;
    }
}
```

Сочетание множества заглушек с множеством «черных ходов» для внедрения зависимостей открывает огромные преимущества:
усиление параллельной разработки, ранняя интеграция с заглушками, когда реальные компоненты недоступны, тестирование
с заглушками, заглушки, которые предоставляют быстрые и хорошо известные демонстрационные данные. В контексте разработки
крупных продуктов массовое использование заглушек - это ключевой метод для параллельной работы и ускорения работы, что
сокращает затраты на ожидание.

## Не используйте заглушки, чтобы отложить интеграцию
Чудесно! Теперь у каждого есть заглушки и у вас есть возможность отложить интеграцию всего кода на месяцы или годы. Даже не
думайте об этом.

## Практикуйте разработку через тестирование / Test-driven development для лучшей архитектуры
[TDD](../tdd) может улучшить архитектуру системы. Как?

Когда мы занимаетесь коучингом, частым запросом наших клиентов является просьбы помочь с "негибкой архитектурой". Это чаще
всего сводится к проблемам в сильной связанности компонентов - распространенная проблема в унаследованном (legacy) коде,
написанном без использования TDD, потому что первоначальный автор не пытался тестировать компоненты независимо.

С другой стороны, когда разработчик создает новый компонент (например, класс) с TDD или проводит рефакторинг устаревшего,
то нужно разорвать зависимости и нарушить связи этого компонента, чтобы он мог быть протестирован изолированно.
Это требует проектирования (или рефакторинга) для внедрения зависимостей и более широкого использования механизмов для
обеспечения гибкости: интерфейсов, полиморфизма, шаблонов проектирования, структур внедрения зависимостей, указателей
функций и многого другого.

В таком случае TDD поощряет слабое связывание, простоту, гибкость конфигурацию - качества хорошей архитектуры.

## Абстрагируйтесь от уровня ресурсов конкретной Операционной Системы
Мы работаем с двумя клиентами над похожими продуктами - крупными встраиваемыми системами. Клиент А создал собственную
операционную систему (OS) и заложился в своих приложениях на специфику данной ОС. Клиент B создал уровень абстракции ОС
поверх своей оригинальной ОС (VxWorks) - уровень абстракции для снижения связанности в этой точке. В какой-то момент оба
клиента решили перейти на операционную систему Linux реального времени. Клиент B закончил порт через пару месяцев;
Через несколько лет Клиент А все еще проводит исследования на предмет возможности перехода. **Гибкость достигается благодаря
низкой связанности уровней**.

Этот совет автоматически выполняется, если вы используете виртуальную машину (например, Java или аналогичную платформу).
Однако большинство наших клиентов при разработке встраиваемых продуктов используют C/C++ стек. В этом случае попробуйте один
из существующих уровней абстракции ОС с открытым исходным кодом, например Boost или Apache Runtime Library.

### Введение в интерфейсы и советы по взаимодействию
Определение и развитие интерфейсов между компонентами и межкомпонентное взаимодействие являются основными проблемами при
разработке больших систем. Фактически, это то, что Грэди Буч(11) назвал "пограничным проектированием"
[Booch96](http://www.amazon.com/Object-Solutions-Managing-Object-Oriented-Project/dp/0805305947), часто является
доминирующей архитектурной проблемой в крупных приложениях. Также обратите внимание, что "боли интеграции" в многосайтовых
или сверхбольших продуктах является отражением взаимодействия команд, их разрабатывающих. Когда вы работаете с монстром
из 15 [MLOC](../DICTIONARY.md#MLOC), состоящим из 234 основных компонентов, каждый из которых содержит в среднем 64
[KLOC](../DICTIONARY.md#KLOC), именно вопросы взаимодействия и интерфейсов, как правило, преобладают в повседневных
архитектурных задачах, а не в дизайне какого-либо одного модуля или даже наличие/отсутствия какого-либо модуля.

**Интерфейсы / Interfaces** – в этом разделе под терминов "интерфейсы" мы имеем ввиду следующее:
- Интерфейсы в языках программирования, например в Java или C# (локальные или удаленные);
- Сигнатуры операций (имя функции и ее параметры);
- Интерфейсы Web-сервисов (например, WSDL);
- и тому подобное.

Большие системы обычно имеют большой возраст; много кода на C для таких систем это нормально, и "интерфейс" для другого
компонента может быть просто сигнатурой функции, такой как `debet (int, float)`. Другой контекст этих советов состоит в том,
что в группе из 250 человек программист, использующий опубликованный API, может отличаться от программиста, который создавал
его реализацию его много лет назад.

## Избегайте подробного проектирования на старте
Старая и бесполезная стратегия для решения проблемы интерфейсов звучала, как "Перед программированием определите и
зафиксируйте интерфейсы между основными компонентами. Затем используйте процесс управления изменениями, когда интерфейсы
будут меняться". Это модель проектирования, ориентированная на раннее проектирование, вызывает следующие проблемы:

- отложенная реализация - из-за сложности и множества вовлеченных людей
- отсутствие обратной связи на основе использования
- неправильные интерфейсы (из-за отсутствия реалистичной обратной связи)
- медленный процесс изменений
- дополнительный код преобразования или адаптации на обеих сторонах интерфейса, чтобы справиться с неизбежной эволюцией,
когда контракт интерфейса зафиксирован.

Далее рассмотрим рабочие альтернативы данном подходу. Следующие рекомендации предлагают концепции "реши-как-можно-позже",
основанные на Бережливом Мышлении.
