# Технические рекомендации / Technically Oriented Tips

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/less/technical-excellence/architecture-design.html#TechnicallyOrientedTips) | *Проверяется* |

За то время, что мы работали с крупными продуктами, обычно это были встраиваемые системы (embedded systems), мы составили
список общих рекомендаций, которые могли бы уменьшить часть боли и страданий, которые на наших глазах испытывают наши
клиенты. В этом разделе перечислены некоторые из этих советов. Но на самом деле эта тема заслуживает отдельной книги ...

## Представьте ваш исходный код в виде HTML-страниц и гиперссылок между ними
В небольшом проекте можно быстро перемещаться по всему исходному коду, просто открытому в вашей среде разработки. Когда, к
примеру, имеется 36 839 файлов и 15 [MLOC](../DICTIONARY.md#MLOC), навигация уже не простая. Используйте бесплатный
инструменты, такие как Doxygen ([www.doxygen.org](http://www.doxygen.org)), чтобы преобразовать ваш исходный код в набор
HTML-страниц, в которых все элементы исходного кода (классы, методы, ...) являются гиперссылками. Doxygen (и аналогичные
инструменты) также будут генерировать диаграммы, отражающие более крупные структуры и группы в вашей кодовой базе.
Регенерируйте страницы ежедневно. Это очень полезно для понимания и развития огромной кодовой базы.

## Используйте заглушки и внедрение зависимостей (dependency injections)
Создавайте заглушки - или «поддельные» альтернативы кода для многих вещей: классов, интерфейсов с другими компонентами,
аппаратного обеспечения и так далее. Заглушки обычно создаются с помощью реализации альтернативного интерфейса или путем
создания подкласса «реального» класса в объектно-ориентированных проектах, или с помощью указателей функций или
альтернативных файлов реализации по изменяющемуся пути ссылки в проектах на основе C
[Feathers04](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), например:
```java
interface PrinterMotor {
    void start();
    …
}

class CanonPrinterMotor implements PrinterMotor {
    …
}

class PrinterMotorStub implements PrinterMotor {
    …
}
```

Если нет интерфейса (и даже если он есть), заглушки могут быть созданы с помощью подклассов и переопределения
соответствующих методов:
```java
class CanonPrinterMotor {
    …
}

class PrinterMotorStub extends CanonPrinterMotor {
    …
}
```

Кроме того, обеспечьте «черный ход» во многих классах, который позволяет легко внедрить альтернативную
заглушку, как зависимость, а не в реальный объект; например, с инжекции в конструктор
[Fowler04](http://martinfowler.com/articles/injection.html).
```java
class LaserPrinter {

private PrinterMotor motor = new CanonPrinterMotor(); // default …

    public Printer (PrinterMotor alternativeMotor) {
        motor = alternativeMotor;
    }
}
```

Сочетание множества заглушек с множеством «черных ходов» для внедрения зависимостей открывает огромные преимущества:
усиление параллельной разработки, ранняя интеграция с заглушками, когда реальные компоненты недоступны, тестирование
с заглушками, заглушки, которые предоставляют быстрые и хорошо известные демонстрационные данные. В контексте разработки
крупных продуктов массовое использование заглушек - это ключевой метод для параллельной работы и ускорения работы, что
сокращает затраты на ожидание.

## Не используйте заглушки, чтобы отложить интеграцию
Чудесно! Теперь у каждого есть заглушки и у вас есть возможность отложить интеграцию всего кода на месяцы или годы. Даже не
думайте об этом.

## Практикуйте разработку через тестирование / Test-driven development для лучшей архитектуры
[TDD](../tdd) может улучшить архитектуру системы. Как?

Когда мы занимаетесь коучингом, частым запросом наших клиентов является просьбы помочь с "негибкой архитектурой". Это чаще
всего сводится к проблемам в сильной связанности компонентов - распространенная проблема в унаследованном (legacy) коде,
написанном без использования TDD, потому что первоначальный автор не пытался тестировать компоненты независимо.

С другой стороны, когда разработчик создает новый компонент (например, класс) с TDD или проводит рефакторинг устаревшего,
то нужно разорвать зависимости и нарушить связи этого компонента, чтобы он мог быть протестирован изолированно.
Это требует проектирования (или рефакторинга) для внедрения зависимостей и более широкого использования механизмов для
обеспечения гибкости: интерфейсов, полиморфизма, шаблонов проектирования, структур внедрения зависимостей, указателей
функций и многого другого.

В таком случае TDD поощряет слабое связывание, простоту, гибкость конфигурацию - качества хорошей архитектуры.

## Абстрагируйтесь от уровня ресурсов конкретной Операционной Системы
Мы работаем с двумя клиентами над похожими продуктами - крупными встраиваемыми системами. Клиент А создал собственную
операционную систему (OS) и заложился в своих приложениях на специфику данной ОС. Клиент B создал уровень абстракции ОС
поверх своей оригинальной ОС (VxWorks) - уровень косвенности для снижения связанности в этой точке. В какой-то момент оба
клиента решили перейти на операционную систему Linux реального времени. Клиент B закончил порт через пару месяцев;
Через несколько лет Клиент А все еще проводит исследования на предмет возможности перехода. **Гибкость достигается благодаря
низкой связанности уровней**.

Этот совет автоматически выполняется, если вы используете виртуальную машину (например, Java или аналогичную платформу).
Однако большинство наших клиентов при разработке встраиваемых продуктов используют C/C++ стек. В этом случае попробуйте один
из существующих уровней абстракции ОС с открытым исходным кодом, например Boost или Apache Runtime Library.

### Введение в интерфейсы и советы по взаимодействию
Определение и развитие интерфейсов между компонентами и межкомпонентное взаимодействие являются основными проблемами при
разработке больших систем. Фактически, это то, что Грэди Буч(11) назвал "пограничным проектированием"
[Booch96](http://www.amazon.com/Object-Solutions-Managing-Object-Oriented-Project/dp/0805305947), часто является
доминирующей архитектурной проблемой в крупных приложениях. Также обратите внимание, что "боли интеграции" в многосайтовых
или сверхбольших продуктах является отражением взаимодействия команд, их разрабатывающих. Когда вы работаете с монстром
из 15 [MLOC](../DICTIONARY.md#MLOC), состоящим из 234 основных компонентов, каждый из которых содержит в среднем 64
[KLOC](../DICTIONARY.md#KLOC), именно вопросы взаимодействия и интерфейсов, как правило, преобладают в повседневных
архитектурных задачах, а не в дизайне какого-либо одного модуля или даже наличие/отсутствия какого-либо модуля.

**Интерфейсы / Interfaces** – в этом разделе под терминов "интерфейсы" мы имеем ввиду следующее:
- Интерфейсы в языках программирования, например в Java или C# (локальные или внешние);
- Сигнатуры операций (имя функции и ее параметры);
- Интерфейсы Web-сервисов (например, WSDL);
- и тому подобное.

Большие системы обычно имеют большой возраст; много кода на C для таких систем это нормально, и "интерфейс" для другого
компонента может быть просто сигнатурой функции, такой как `debet (int, float)`. Другой контекст этих советов состоит в том,
что в группе из 250 человек программист, использующий опубликованный API, может отличаться от программиста, который создавал
его реализацию его много лет назад.

## Избегайте подробного проектирования на старте
Старая и бесполезная стратегия для решения проблемы интерфейсов звучала, как "Перед программированием определите и
зафиксируйте интерфейсы между основными компонентами. Затем используйте процесс управления изменениями, когда интерфейсы
будут меняться". Это модель проектирования, ориентированная на раннее проектирование, вызывает следующие проблемы:

- отложенная реализация - из-за сложности и множества вовлеченных людей
- отсутствие обратной связи на основе использования
- неправильные интерфейсы (из-за отсутствия реалистичной обратной связи)
- медленный процесс изменений
- дополнительный код преобразования или адаптации на обеих сторонах интерфейса, чтобы справиться с неизбежной эволюцией,
когда контракт интерфейса зафиксирован.

Далее рассмотрим рабочие альтернативы данном подходу. Следующие рекомендации предлагают концепции "реши-как-можно-позже",
основанные на Бережливом Мышлении.

## Упрощайте координацию процессом изменения интерфейсов путем создания фиче-команд
[Фиче-команда](https://less.works/less/structure/feature-teams.html) является межкомпонентной и изменяет весь код во всех
компонентах, необходимых для выполнения, ориентированной на клиента функции. Это уменьшает проблемы координации, связанные с
интерфейсами, потому что один и тот же человек или команда работают, как над вызывающей, так и над вызываемой стороне
интерфейса. Напротив, выделенные команды компонентов увеличивают сложность координации процесса изменения интерфейса.

## Избегайте "замороженных" интерфейсов
Есть моменты, когда публичный API действительно необходимо заморозить. Но оспаривайте эти решения, держите как можно больше
артефактов доступными для изменения и экспериментируйте с методами поддержки эволюции интерфейсов. Некоторые методы
будут предложены здесь, а другие - в разделе [Что почитать](recommended-readings.md).

## Оборачивайте вызовы внешних компонентов с помощью Proxy или Adapter
*Внешние* компоненты, вызов которых происходит через JMI, RPC, SOAP, промежуточное ПО, ориентированное на сообщения (MOM)
или сокеты, являются *гарантированными* точками, в которых могут быть внедрены заглушки для возможности изолированного
тестирования без обращения к реальным экземплярам. Кроме того, часто меняется сам протокол удаленного взаимодействия
(например, переход с RPC на MOM).

Следовательно, вам должны защититься в этих **точках изменения архитектура**, всегда оборачивая вызовы во внешние компоненты,
используя полиморфизм, шаблоны проектирования Proxy или Adapter
[GHJV94](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612).

## Начинайте с использования интерфейсов во взаимодействии основных компонентов, потом удалите их, если потребуется
Большие системы обычно состоят из сотен основных компонентов, и они могут быть как внутренними, так удаленными друг от друга.
Мы видим общие проблемы, связанные с взаимодействием между основными компонентами (такими как подсистемы) в больших системах:

- зависимость от знаний того, какой основной компонент является получателем сообщения или вызова операции
- зависимость от знаний протоколов взаимодействия, таких, как прямой вызов функции, RPC, SOAP через HTTP и т. д.
- обработка сложных и повторяющихся ошибок сети
- невозможность использования подключаемых модулей / компонентов из-за проблем, связанных с их сильной связанностью

Следующий совет может помочь ...

Профессор информатики Дэвид Уилер (David Wheeler), как известно, говорил: "Все проблемы в информатике могут быть решены с
помощью другого уровня косвенности".

Решение вышеуказанных проблем заключается в использовании косвенного механизма связи между основными крупными компонентами
(такими как подсистемы), в отличие от чего-то прямого, такого как вызов Java RMI или SOAP. Это "косвенное взаимодействие"
глубже, чем просто добавление адаптера или прокси между компонентами; это означает использование какой-либо формы косвенной
системы обмена сообщениями.

Существует несколько вариантов косвенного обмена сообщениями между основными крупными компонентами. Одним из надежных
вариантов является промежуточное программное обеспечение, ориентированное на сообщения (MOM), такое как JMS и MSMQ. MOM,
богатый на опции, поддерживающий плагины, заслуживает внимательного изучения. Решения MOM для домашнего использования или
с открытым исходным кодом, более легкие "шины сообщений", являются еще одним вариантом. Выполнение межкомпонентной связи с
MOM обеспечивает степень свободы, которая обеспечивает более низкую связь и архитектуру, позволяющую использовать плагины.
Решения MOM также предлагают встроенные функции отказоустойчивости и восстановления.

Также существует вторая часть цитаты Уилера, которая наименее известна. Приводим цитату полностью

> Все проблемы в информатике могут быть решены с помощью другого уровня косвенности. Но обычно это создает другую проблему.

Иногда, "другая проблема" - это влияние на производительность.

Потенциальным недостатком MOM является снижение производительности. В этом случае, как и в случае со слабо типизированным
интерфейсом, вы можете начать с решения MOM, чтобы обнаружить "линий желаний" в коммуникации модулей, игнорируя при этом
снижение производительности. Затем, по мере стабилизации каналов взаимодействия и обнаружения узких мест с точки зрения
производительности, вы замените медленные взаимодействия MOM более быстрыми механизмами, такими как Java RMI. Это еще один
пример "вытягивающего" проектирования. MOM остается механизмом по умолчанию, если он не является производительным для случая.

Если этот совет сочетать с рекомендацией всегда использовать Proxy или Adapter для связи с внешними
компонентами, то изменение протокола с MOM на RMI на внутренний код никак не влияет - нужно просто добавить
альтернативный адаптер.
