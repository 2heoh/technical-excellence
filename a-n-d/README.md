# Архитектура и Проектирование / Architecture & Design

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/less/technical-excellence/architecture-design.html) | *В работе* |

## Содержание

- [Введение](#Введение)
- [Забота о проектировании](#Забота-о-проектировании)
- [Поведенческие рекомендации](#Поведенческие-рекомендации)
- [Технические рекомендации](#Технические-рекомендации)
- [Заключение](#Заключение)
- [Полезные ссылки](#Полезные-ссылки)
- [Сноски](#Сноски)

## Введение

> Существует 10 типа людей: кто понимает двоичный формат и кто нет.
> -- неизвестный автор

В ландшафтной дизайне существует эволюционная методика проектирования с использованием "линий желаний".

![desire_line.jpq](https://less.works/img/design_&_architecture/xdesire_line.jpg.pagespeed.ic.w8uuycckG8.webp)

**Проблема**: Где проложить дорожки для прогулок? Какими широкими они должны быть?
**Решение**: Подождите год и наблюдайте за тем, как люди естественным образом гуляют. Создавайте дорожки вдоль этих “линий
желаний” такими широкими, насколько часто по ним гуляют. Дизайн подчиняется спросу, а не устанавливается спекулятивно.
Несмотря на сложность применения в проектировании ПО, описанный выше подход является одним из источников вдохновения при
бережливой или гибкой разработке, а также вариантом эмерджентного проектирования (1).

Вероятно, это тема для большой книги, например “Гибкое Проектирование в Масштабе”, но это не так. Это не трактат о
техническом дизайне; он предлагает несколько ориентированных на поведение советов, связанных с проектированием и
крупномасштабной гибкой разработкой, с несколькими заслуживающими внимания технически ориентированными советами - некоторые
из которых аналогичны “линиям желаний”. Некоторые советы отражают принципы бережливой разработки программного обеспечения,
такие “решить как можно позже”. Некоторые отражают принципы Манифеста гибкой разработки, такие как “самый эффективный и
эффективный способ передачи информации - это общение лицом к лицу”. И многие предложения поддерживают девятый принцип этого
манифеста: постоянное внимание к техническому совершенству и качеству проектирования повышает гибкость проекта.

## Забота о проектировании

### "Садоводство", а не "строительство" - Создавайте культуру живого, растущего дизайна

Мы хотели назвать этот раздел просто «Проектирование», но решили остановиться на названии «Архитектура и Проектирование»
из-за существующей веры в то, что программный код, дизайн и архитектура - это разные вещи, и поэтому создание архитектуры и
программирование - это разные вещи тоже.

Слово «архитектура» имеет, по крайней мере, два общих значения в общем понимании при разработке программного обеспечения:

- (сущ.) крупномасштабные статические и динамические структуры и шаблоны
также необходимая архитектура (предполагаемая, желаемая) по сравнению с текущей -  которая может быть не достижима

- (гл.) создание и определение предполагаемой архитектуры, как в «подготовка архитектуры» или «когда вы будете готовить
архитектуру?»
выполняется один раз в начале проекта часто в документах это пересекается с анализом требований.

Термин был заимствован у “классических” архитекторов, которые проектируют материальные объекты: здания и сооружения.
Такая аналогия(3) становиться слабой с интересными побочными эффектами для разработки программного обеспечения.
Здания являются “твердыми” (hard), и поэтому в этой области проектирование архитектуры выполняется только один раз перед
началом строительством - по крайней мере, в наши дни - и затем они почти не меняются. Отметим также, что архитекторы
отличаются от строителей.

Но программное обеспечение - это не здание, программное обеспечение “мягкое” (software - soft), а программирование - это
не процесс строительства; «Архитектура программного обеспечения» - это всего лишь одна несовершенная аналогия из большого
списка доступных метафор.

Какие еще метафоры применимы? Можно процитировать статью Джека Ривза «Что такое дизайн программного обеспечения?»

> … Единственная документация, которая на самом деле описывает достоверно дизайн системы, это ее исходный код

По мнению Крейга Лармана, со-создателя LeSS и автора книги по анализу программного обеспечения, проектированию,
моделированию, шаблонам и архитектуре, работавшего с 1970-х годов в качестве программиста, диаграммы и документы - это не
настоящий дизайн, настоящий дизайн - это исходный код.

Исходный код (в C, C ++, ...) является настоящим планом. И в основном только в контексте программного обеспечения “билд”
или сборка практически бесплатны и мгновенны. Следовательно, многие не видят его таким, какой он есть: Сборка - это этап
компиляции и компоновки. Не случайно, что в инструментах разработки пункт меню для запуска компиляции называется “Сборка”
(“билд”, Build).

![build_menu.jpq](https://less.works/img/design_&_architecture/xbuild_menu.png.pagespeed.ic.UcDpOxTQ09.webp)

Сценарий: В первые дни существования Продукта Х предположим, что существовали высокоуровневые проектные документы для
крупных элементов системы, идиом и взаимодействий в рамках предполагаемой архитектуры, и предположим, что реальный дизайн
(исходный код) хорошо отражает эти требования. Прошло семь лет и все программисты, которые начинали разработку, больше не
работают, а были наняты 300 новых разработчиков, которые не очень квалифицированы и на самом деле не знают или не заботятся
об первоначальных концепциях высокоуровневого дизайна. Представьте, что они добавили 9,5 миллиона строк кода - 9,5 MLOC,
предположим, что это 95 процентов всего кода - и это беспорядок.

Где настоящая архитектура - хорошая или плохая, намеренная или случайная? Это в документах, поддерживаемых (или нет) группой
архитектуры, или это в 10 MLOC C и C ++ кода в пределах десятков тысяч файлов? Очевидно, что последнее - исходный код
является реальным проектом, и только он отражает истинный крупномасштабный дизайн или архитектуру. Архитектура - это то,
что есть, а не то, что хочется. «Архитектура» в программной системе не обязательно является какой-либо хорошей или
намеренной.

**Первое наблюдение** - *Сумма всего исходного кода - это настоящий архитектурный план проекта или программная архитектура.*

Дизайн / код программного обеспечения улучшается или ухудшается с каждым днем, с каждой строкой кода, добавляемой или
изменяемой разработчиками. Архитектура программного обеспечения не является статичной вещью. Программное обеспечение - это
живое существо, больше похожее на растение или сад, чем на здание, и живой дизайн или архитектура день ото дня становятся
лучше или хуже.

**Второе наблюдение** - *Реальная архитектура программного обеспечения развивается (становится лучше или хуже) каждый день
жизни продукта, так как люди меняют исходный код.*

Аналогия с садоводством, парками и растениями является ценной. Например, существует ландшафтная архитектура существительного
и глагола - это нормально и умело учитывать и «проектировать» общую картину при планировании большого сада или парка. И все
же люди не оставляют это при этом. Из-за видимой природы парка и из-за того, что растения растут, кристально ясно, что
фактическая ландшафтная архитектура быстро превратится в джунгли сорняков без постоянного садоводства или обрезки от
практических садоводов, помня об оригинальном или развивающемся видении парка , У нас есть друг, который работает
ландшафтным архитектором для полей для гольфа. Он видит своими глазами детали реального, живого курса, пока он создается,
обходит его и играет в гольф - в связи с реальностью того, что есть.

...

## Поведенческие рекомендации

...

## Технические рекомендации

За то время, что мы работали с крупными продуктами, обычно это были встраиваемые системы (embedded systems), мы составили
список общих рекомендаций, которые могли бы уменьшить часть боли и страданий, которые на наших глазах испытывают наши
клиенты. В этом разделе перечислены некоторые из этих советов. Но на самом деле эта тема заслуживает отдельной книги ...

### Представьте ваш исходный код в виде HTML-страниц и гиперссылок между ними

В небольшом проекте можно быстро перемещаться по всему исходному коду, просто открытому в вашей среде разработки. Когда, к
примеру, имеется 36 839 файлов и 15 [MLOC](../DICTIONARY.md#MLOC), навигация уже не простая. Используйте бесплатный
инструменты, такие как Doxygen ([www.doxygen.org](http://www.doxygen.org)), чтобы преобразовать ваш исходный код в набор
HTML-страниц, в которых все элементы исходного кода (классы, методы, ...) являются гиперссылками. Doxygen (и аналогичные
инструменты) также будут генерировать диаграммы, отражающие более крупные структуры и группы в вашей кодовой базе.
Регенерируйте страницы ежедневно. Это очень полезно для понимания и развития огромной кодовой базы.

### Используйте заглушки и внедрение зависимостей (dependency injections)

Создавайте заглушки - или «поддельные» альтернативы кода для многих вещей: классов, интерфейсов с другими компонентами,
аппаратного обеспечения и так далее. Заглушки обычно создаются с помощью реализации альтернативного интерфейса или путем
создания подкласса «реального» класса в объектно-ориентированных проектах, или с помощью указателей функций или
альтернативных файлов реализации по изменяющемуся пути ссылки в проектах на основе C
[Feathers04](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052), например:

```java
interface PrinterMotor {
    void start();
    …
}

class CanonPrinterMotor implements PrinterMotor {
    …
}

class PrinterMotorStub implements PrinterMotor {
    …
}
```

Если нет интерфейса (и даже если он есть), заглушки могут быть созданы с помощью подклассов и переопределения
соответствующих методов:

```java
class CanonPrinterMotor {
    …
}

class PrinterMotorStub extends CanonPrinterMotor {
    …
}
```

Кроме того, обеспечьте «черный ход» во многих классах, который позволяет легко внедрить альтернативную
заглушку, как зависимость, а не в реальный объект; например, с инжекции в конструктор
[Fowler04](http://martinfowler.com/articles/injection.html).

```java
class LaserPrinter {

private PrinterMotor motor = new CanonPrinterMotor(); // default …

    public Printer (PrinterMotor alternativeMotor) {
        motor = alternativeMotor;
    }
}
```

Сочетание множества заглушек с множеством «черных ходов» для внедрения зависимостей открывает огромные преимущества:
усиление параллельной разработки, ранняя интеграция с заглушками, когда реальные компоненты недоступны, тестирование
с заглушками, заглушки, которые предоставляют быстрые и хорошо известные демонстрационные данные. В контексте разработки
крупных продуктов массовое использование заглушек - это ключевой метод для параллельной работы и ускорения работы, что
сокращает затраты на ожидание.

### Не используйте заглушки, чтобы отложить интеграцию

Чудесно! Теперь у каждого есть заглушки и у вас есть возможность отложить интеграцию всего кода на месяцы или годы. Даже не
думайте об этом.

### Практикуйте разработку через тестирование / Test-driven development для лучшей архитектуры

[TDD](../tdd) может улучшить архитектуру системы. Как?

Когда мы занимаетесь коучингом, частым запросом наших клиентов является просьбы помочь с "негибкой архитектурой". Это чаще
всего сводится к проблемам в сильной связанности компонентов - распространенная проблема в унаследованном (legacy) коде,
написанном без использования TDD, потому что первоначальный автор не пытался тестировать компоненты независимо.

С другой стороны, когда разработчик создает новый компонент (например, класс) с TDD или проводит рефакторинг устаревшего,
то нужно разорвать зависимости и нарушить связи этого компонента, чтобы он мог быть протестирован изолированно.
Это требует проектирования (или рефакторинга) для внедрения зависимостей и более широкого использования механизмов для
обеспечения гибкости: интерфейсов, полиморфизма, шаблонов проектирования, структур внедрения зависимостей, указателей
функций и многого другого.

В таком случае TDD поощряет слабое связывание, простоту, гибкость конфигурацию - качества хорошей архитектуры.

### Абстрагируйтесь от уровня ресурсов конкретной Операционной Системы

Мы работаем с двумя клиентами над похожими продуктами - крупными встраиваемыми системами. Клиент А создал собственную
операционную систему (OS) и заложился в своих приложениях на специфику данной ОС. Клиент B создал уровень абстракции ОС
поверх своей оригинальной ОС (VxWorks) - уровень косвенности для снижения связанности в этой точке. В какой-то момент оба
клиента решили перейти на операционную систему Linux реального времени. Клиент B закончил порт через пару месяцев;
Через несколько лет Клиент А все еще проводит исследования на предмет возможности перехода. **Гибкость достигается благодаря
низкой связанности уровней**.

Этот совет автоматически выполняется, если вы используете виртуальную машину (например, Java или аналогичную платформу).
Однако большинство наших клиентов при разработке встраиваемых продуктов используют C/C++ стек. В этом случае попробуйте один
из существующих уровней абстракции ОС с открытым исходным кодом, например Boost или Apache Runtime Library.

#### Введение в интерфейсы и советы по взаимодействию

Определение и развитие интерфейсов между компонентами и межкомпонентное взаимодействие являются основными проблемами при
разработке больших систем. Фактически, это то, что Грэди Буч(11) назвал "пограничным проектированием"
[Booch96](http://www.amazon.com/Object-Solutions-Managing-Object-Oriented-Project/dp/0805305947), часто является
доминирующей архитектурной проблемой в крупных приложениях. Также обратите внимание, что "боли интеграции" в многосайтовых
или сверхбольших продуктах является отражением взаимодействия команд, их разрабатывающих. Когда вы работаете с монстром
из 15 [MLOC](../DICTIONARY.md#MLOC), состоящим из 234 основных компонентов, каждый из которых содержит в среднем 64
[KLOC](../DICTIONARY.md#KLOC), именно вопросы взаимодействия и интерфейсов, как правило, преобладают в повседневных
архитектурных задачах, а не в дизайне какого-либо одного модуля или даже наличие/отсутствия какого-либо модуля.

**Интерфейсы / Interfaces** – в этом разделе под терминов "интерфейсы" мы имеем ввиду следующее:

- Интерфейсы в языках программирования, например в Java или C# (локальные или внешние);
- Сигнатуры операций (имя функции и ее параметры);
- Интерфейсы Web-сервисов (например, WSDL);
- и тому подобное.

Большие системы обычно имеют большой возраст; много кода на C для таких систем это нормально, и "интерфейс" для другого
компонента может быть просто сигнатурой функции, такой как `debet (int, float)`. Другой контекст этих советов состоит в том,
что в группе из 250 человек программист, использующий опубликованный API, может отличаться от программиста, который создавал
его реализацию его много лет назад.

### Избегайте подробного проектирования на старте

Старая и бесполезная стратегия для решения проблемы интерфейсов звучала, как "Перед программированием определите и
зафиксируйте интерфейсы между основными компонентами. Затем используйте процесс управления изменениями, когда интерфейсы
будут меняться". Это модель проектирования, ориентированная на раннее проектирование, вызывает следующие проблемы:

- отложенная реализация - из-за сложности и множества вовлеченных людей
- отсутствие обратной связи на основе использования
- неправильные интерфейсы (из-за отсутствия реалистичной обратной связи)
- медленный процесс изменений
- дополнительный код преобразования или адаптации на обеих сторонах интерфейса, чтобы справиться с неизбежной эволюцией,
когда контракт интерфейса зафиксирован.

Далее рассмотрим рабочие альтернативы данном подходу. Следующие рекомендации предлагают концепции "реши-как-можно-позже",
основанные на Бережливом Мышлении.

### Упрощайте координацию процессом изменения интерфейсов путем создания фиче-команд

[Фиче-команда](https://less.works/less/structure/feature-teams.html) является межкомпонентной и изменяет весь код во всех
компонентах, необходимых для выполнения, ориентированной на клиента функции. Это уменьшает проблемы координации, связанные с
интерфейсами, потому что один и тот же человек или команда работают, как над вызывающей, так и над вызываемой стороне
интерфейса. Напротив, выделенные команды компонентов увеличивают сложность координации процесса изменения интерфейса.

### Избегайте "замороженных" интерфейсов

Есть моменты, когда публичный API действительно необходимо заморозить. Но оспаривайте эти решения, держите как можно больше
артефактов доступными для изменения и экспериментируйте с методами поддержки эволюции интерфейсов. Некоторые методы
будут предложены здесь, а другие - в разделе [Полезные ссылки](#Полезные-ссылки).

### Оборачивайте вызовы внешних компонентов с помощью Proxy или Adapter

*Внешние* компоненты, вызов которых происходит через JMI, RPC, SOAP, промежуточное ПО, ориентированное на сообщения (MOM)
или сокеты, являются *гарантированными* точками, в которых могут быть внедрены заглушки для возможности изолированного
тестирования без обращения к реальным экземплярам. Кроме того, часто меняется сам протокол удаленного взаимодействия
(например, переход с RPC на MOM).

Следовательно, вам должны защититься в этих **точках изменения архитектура**, всегда оборачивая вызовы во внешние компоненты,
используя полиморфизм, шаблоны проектирования Proxy или Adapter
[GHJV94](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612).

### Начинайте с использования интерфейсов во взаимодействии основных компонентов, потом удалите их, если потребуется

Большие системы обычно состоят из сотен основных компонентов, и они могут быть как внутренними, так удаленными друг от друга.
Мы видим общие проблемы, связанные с взаимодействием между основными компонентами (такими как подсистемы) в больших системах:

- зависимость от знаний того, какой основной компонент является получателем сообщения или вызова операции
- зависимость от знаний протоколов взаимодействия, таких, как прямой вызов функции, RPC, SOAP через HTTP и т. д.
- обработка сложных и повторяющихся ошибок сети
- невозможность использования подключаемых модулей / компонентов из-за проблем, связанных с их сильной связанностью

Следующий совет может помочь ...

Профессор информатики Дэвид Уилер (David Wheeler), как известно, говорил: "Все проблемы в информатике могут быть решены с
помощью другого уровня косвенности".

Решение вышеуказанных проблем заключается в использовании косвенного механизма связи между основными крупными компонентами
(такими как подсистемы), в отличие от чего-то прямого, такого как вызов Java RMI или SOAP. Это "косвенное взаимодействие"
глубже, чем просто добавление адаптера или прокси между компонентами; это означает использование какой-либо формы косвенной
системы обмена сообщениями.

Существует несколько вариантов косвенного обмена сообщениями между основными крупными компонентами. Одним из надежных
вариантов является промежуточное программное обеспечение, ориентированное на сообщения (MOM), такое как JMS и MSMQ. MOM,
богатый на опции, поддерживающий плагины, заслуживает внимательного изучения. Решения MOM для домашнего использования или
с открытым исходным кодом, более легкие "шины сообщений", являются еще одним вариантом. Выполнение межкомпонентной связи с
MOM обеспечивает степень свободы, которая обеспечивает более низкую связь и архитектуру, позволяющую использовать плагины.
Решения MOM также предлагают встроенные функции отказоустойчивости и восстановления.

Также существует вторая часть цитаты Уилера, которая наименее известна. Приводим цитату полностью

> Все проблемы в информатике могут быть решены с помощью другого уровня косвенности. Но обычно это создает другую проблему.

Иногда, "другая проблема" - это влияние на производительность.

Потенциальным недостатком MOM является снижение производительности. В этом случае, как и в случае со слабо типизированным
интерфейсом, вы можете начать с решения MOM, чтобы обнаружить "линий желаний" в коммуникации модулей, игнорируя при этом
снижение производительности. Затем, по мере стабилизации каналов взаимодействия и обнаружения узких мест с точки зрения
производительности, вы замените медленные взаимодействия MOM более быстрыми механизмами, такими как Java RMI. Это еще один
пример "вытягивающего" проектирования. MOM остается механизмом по умолчанию, если он не является производительным для случая.

Если этот совет сочетать с рекомендацией всегда использовать Proxy или Adapter для связи с внешними
компонентами, то изменение протокола с MOM на RMI на внутренний код никак не влияет - нужно просто добавить
альтернативный адаптер.

## Заключение

Здания жесткие и неподвижные. Программное обеспечение гибкое и динамичное. Таким образом, "архитектура" далека от идеальной
метафоры для создания программного обеспечения; это может даже способствовать неправильному пониманию того, что существует
какое-то проектирование, оторванное от исходного кода, и что оно по существу не меняется.

Но программное обеспечение постоянно развивается и обновляется с каждой модификацией исходного кода каждым программистом.
Ключевой вопрос: станет ли оно красивым и ухоженным садом или джунглями сорняков?

Советы, приведенные здесь, поощряют высококачественное эмерджентное проектирование благодаря культуре развития садоводства и
более коротких и ценных циклов обратной связи, а не "архитектуре". А для этого нужны великие садоводы:
архитекторы-программисты, которые активно создают архитектуру и постоянно обучают других программистов во время
парного программирования и воркшопов по моделированию.

Для устойчивых крупномасштабных гибких систем людям жизненно важно освоить гибкие методы проектирования: шаблоны
проектирования, внедрение зависимостей, разработку через тестирование, рефакторинг и многое другое. Но без коучинга со
стороны технических экспертов во время написания кода эти методы не будут приниматься и распространяться среди разработчиков.

Мы не предлагаем никакой ложной дихотомии между разработкой и проектированием; последнее ценно, особенно в крупных системах.
Помимо сосредоточения внимания на коде, воркшопы по моделированию - это отличная и легкая техника, позволяющая быстро
исследовать сложные конструкции и учиться вместе. Возможно, ключевым ингредиентом являются массивные "белые доски", поэтому
займите ими все стены!

## Полезные ссылки

## Сноски

### 1

Нет никакой ложной дихотомии. Этот пример не означает, что нужно избегать технического совершенства или тщательного
проектирования. Он лишь предлагает проектирование и архитектуру, которые прекрасно адаптированы быть более отзывчивыми к
новым знаниями.
